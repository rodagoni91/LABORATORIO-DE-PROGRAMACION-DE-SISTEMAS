using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\dany_\\Desktop\\Calculadora1.g 2020-09-24 16:47:19

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class Calculadora1Parser : Antlr.Runtime.Parser
{
    internal static readonly string[] tokenNames = new string[] {
        "<invalid>", "<EOR>", "<DOWN>", "<UP>", "ENTRE", "INT", "MAS", "MENOS", "NEWLINE", "PAREND", "PARENI", "POR", "WS"
    };
    public const int EOF = -1;
    public const int ENTRE = 4;
    public const int INT = 5;
    public const int MAS = 6;
    public const int MENOS = 7;
    public const int NEWLINE = 8;
    public const int PAREND = 9;
    public const int PARENI = 10;
    public const int POR = 11;
    public const int WS = 12;

#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false
			};
#else
    private static readonly bool[] decisionCanBacktrack = new bool[0];
#endif
    public Calculadora1Parser(ITokenStream input)
        : this(input, new RecognizerSharedState())
    {
    }
    public Calculadora1Parser(ITokenStream input, RecognizerSharedState state)
        : base(input, state)
    {
        OnCreated();
    }

    public override string[] TokenNames { get { return Calculadora1Parser.tokenNames; } }
    public override string GrammarFileName { get { return "C:\\Users\\dany_\\Desktop\\Calculadora1.g"; } }


    [Conditional("ANTLR_TRACE")]
    protected virtual void OnCreated() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule(string ruleName, int ruleIndex) { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule(string ruleName, int ruleIndex) { }

    #region Rules

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_programa() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_programa() { }

    // $ANTLR start "programa"
    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:13:1: programa returns [int value] : stat ;
    [GrammarRule("programa")]
    private int programa()
    {
        EnterRule_programa();
        EnterRule("programa", 1);
        TraceIn("programa", 1);
        int value = default(int);


        int stat1 = default(int);

        try
        {
            DebugEnterRule(GrammarFileName, "programa");
            DebugLocation(13, 1);
            try
            {
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:14:2: ( stat )
                DebugEnterAlt(1);
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:14:4: stat
                {
                    DebugLocation(14, 4);
                    PushFollow(Follow._stat_in_programa61);
                    stat1 = stat();
                    PopFollow();

                    DebugLocation(14, 8);
                    System.Console.WriteLine(stat1);

                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("programa", 1);
                LeaveRule("programa", 1);
                LeaveRule_programa();
            }
            DebugLocation(15, 1);
        }
        finally { DebugExitRule(GrammarFileName, "programa"); }
        return value;

    }
    // $ANTLR end "programa"


    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_stat() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_stat() { }

    // $ANTLR start "stat"
    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:17:1: stat returns [int value] : (c= expresion NEWLINE | NEWLINE );
    [GrammarRule("stat")]
    private int stat()
    {
        EnterRule_stat();
        EnterRule("stat", 2);
        TraceIn("stat", 2);
        int value = default(int);


        int c = default(int);

        try
        {
            DebugEnterRule(GrammarFileName, "stat");
            DebugLocation(17, 8);
            try
            {
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:18:2: (c= expresion NEWLINE | NEWLINE )
                int alt1 = 2;
                try
                {
                    DebugEnterDecision(1, decisionCanBacktrack[1]);
                    int LA1_0 = input.LA(1);

                    if ((LA1_0 == INT || LA1_0 == PARENI))
                    {
                        alt1 = 1;
                    }
                    else if ((LA1_0 == NEWLINE))
                    {
                        alt1 = 2;
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(1); }
                switch (alt1)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // C:\\Users\\dany_\\Desktop\\Calculadora1.g:19:2: c= expresion NEWLINE
                        {
                            DebugLocation(19, 4);
                            PushFollow(Follow._expresion_in_stat90);
                            c = expresion();
                            PopFollow();

                            DebugLocation(19, 16);
                            Match(input, NEWLINE, Follow._NEWLINE_in_stat92);
                            DebugLocation(19, 24);
                            System.Console.WriteLine(c);

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // C:\\Users\\dany_\\Desktop\\Calculadora1.g:20:2: NEWLINE
                        {
                            DebugLocation(20, 2);
                            Match(input, NEWLINE, Follow._NEWLINE_in_stat98);

                        }
                        break;

                }
            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("stat", 2);
                LeaveRule("stat", 2);
                LeaveRule_stat();
            }
            DebugLocation(20, 8);
        }
        finally { DebugExitRule(GrammarFileName, "stat"); }
        return value;

    }
    // $ANTLR end "stat"


    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_expresion() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_expresion() { }

    // $ANTLR start "expresion"
    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:22:1: expresion returns [int value] : a= multiplicacion ( MAS b= multiplicacion | MENOS b= multiplicacion )* ;
    [GrammarRule("expresion")]
    public int expresion()
    {
        EnterRule_expresion();
        EnterRule("expresion", 3);
        TraceIn("expresion", 3);
        int value = default(int);


        int a = default(int);
        int b = default(int);

        try
        {
            DebugEnterRule(GrammarFileName, "expresion");
            DebugLocation(22, 1);
            try
            {
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:23:2: (a= multiplicacion ( MAS b= multiplicacion | MENOS b= multiplicacion )* )
                DebugEnterAlt(1);
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:24:2: a= multiplicacion ( MAS b= multiplicacion | MENOS b= multiplicacion )*
                {
                    DebugLocation(24, 4);
                    PushFollow(Follow._multiplicacion_in_expresion125);
                    a = multiplicacion();
                    PopFollow();

                    DebugLocation(24, 20);
                    value = a;
                    DebugLocation(24, 41);
                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:24:41: ( MAS b= multiplicacion | MENOS b= multiplicacion )*
                    try
                    {
                        DebugEnterSubRule(2);
                        while (true)
                        {
                            int alt2 = 3;
                            try
                            {
                                DebugEnterDecision(2, decisionCanBacktrack[2]);
                                int LA2_0 = input.LA(1);

                                if ((LA2_0 == MAS))
                                {
                                    alt2 = 1;
                                }
                                else if ((LA2_0 == MENOS))
                                {
                                    alt2 = 2;
                                }


                            }
                            finally { DebugExitDecision(2); }
                            switch (alt2)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:25:2: MAS b= multiplicacion
                                    {
                                        DebugLocation(25, 2);
                                        Match(input, MAS, Follow._MAS_in_expresion133);
                                        DebugLocation(25, 8);
                                        PushFollow(Follow._multiplicacion_in_expresion139);
                                        b = multiplicacion();
                                        PopFollow();

                                        DebugLocation(25, 25);
                                        value = value + b;
                                        //System.Console.WriteLine(value.ToString() + "+" + b.ToString() + "\n");

                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:27:2: MENOS b= multiplicacion
                                    {
                                        DebugLocation(27, 2);
                                        Match(input, MENOS, Follow._MENOS_in_expresion151);
                                        DebugLocation(27, 10);
                                        PushFollow(Follow._multiplicacion_in_expresion157);
                                        b = multiplicacion();
                                        PopFollow();

                                        DebugLocation(27, 26);
                                        value = value - b;

                                    }
                                    break;

                                default:
                                    goto loop2;
                            }
                        }

                    loop2:
                        ;

                    }
                    finally { DebugExitSubRule(2); }

                    DebugLocation(27, 55);
                    //System.Console.WriteLine(value);

                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("expresion", 3);
                LeaveRule("expresion", 3);
                LeaveRule_expresion();
            }
            DebugLocation(28, 1);
        }
        finally { DebugExitRule(GrammarFileName, "expresion"); }
        return value;

    }
    // $ANTLR end "expresion"


    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_multiplicacion() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_multiplicacion() { }

    // $ANTLR start "multiplicacion"
    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:30:1: multiplicacion returns [int value] : a= numero ( POR b= numero | ENTRE b= numero )* ;
    [GrammarRule("multiplicacion")]
    private int multiplicacion()
    {
        EnterRule_multiplicacion();
        EnterRule("multiplicacion", 4);
        TraceIn("multiplicacion", 4);
        int value = default(int);


        int a = default(int);
        int b = default(int);

        try
        {
            DebugEnterRule(GrammarFileName, "multiplicacion");
            DebugLocation(30, 1);
            try
            {
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:31:2: (a= numero ( POR b= numero | ENTRE b= numero )* )
                DebugEnterAlt(1);
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:32:2: a= numero ( POR b= numero | ENTRE b= numero )*
                {
                    DebugLocation(32, 4);
                    PushFollow(Follow._numero_in_multiplicacion188);
                    a = numero();
                    PopFollow();

                    DebugLocation(32, 12);
                    value = a;
                    DebugLocation(32, 34);
                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:32:34: ( POR b= numero | ENTRE b= numero )*
                    try
                    {
                        DebugEnterSubRule(3);
                        while (true)
                        {
                            int alt3 = 3;
                            try
                            {
                                DebugEnterDecision(3, decisionCanBacktrack[3]);
                                int LA3_0 = input.LA(1);

                                if ((LA3_0 == POR))
                                {
                                    alt3 = 1;
                                }
                                else if ((LA3_0 == ENTRE))
                                {
                                    alt3 = 2;
                                }


                            }
                            finally { DebugExitDecision(3); }
                            switch (alt3)
                            {
                                case 1:
                                    DebugEnterAlt(1);
                                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:33:2: POR b= numero
                                    {
                                        DebugLocation(33, 2);
                                        Match(input, POR, Follow._POR_in_multiplicacion199);
                                        DebugLocation(33, 8);
                                        PushFollow(Follow._numero_in_multiplicacion205);
                                        b = numero();
                                        PopFollow();

                                        DebugLocation(33, 16);
                                        value = value * b;

                                    }
                                    break;
                                case 2:
                                    DebugEnterAlt(2);
                                    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:35:2: ENTRE b= numero
                                    {
                                        DebugLocation(35, 2);
                                        Match(input, ENTRE, Follow._ENTRE_in_multiplicacion214);
                                        DebugLocation(35, 10);
                                        PushFollow(Follow._numero_in_multiplicacion220);
                                        b = numero();
                                        PopFollow();

                                        DebugLocation(35, 18);
                                        value = value / b;

                                    }
                                    break;

                                default:
                                    goto loop3;
                            }
                        }

                    loop3:
                        ;

                    }
                    finally { DebugExitSubRule(3); }


                }

            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("multiplicacion", 4);
                LeaveRule("multiplicacion", 4);
                LeaveRule_multiplicacion();
            }
            DebugLocation(36, 1);
        }
        finally { DebugExitRule(GrammarFileName, "multiplicacion"); }
        return value;

    }
    // $ANTLR end "multiplicacion"


    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_numero() { }
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_numero() { }

    // $ANTLR start "numero"
    // C:\\Users\\dany_\\Desktop\\Calculadora1.g:37:1: numero returns [int value] : ( INT | PARENI expresion PAREND );
    [GrammarRule("numero")]
    private int numero()
    {
        EnterRule_numero();
        EnterRule("numero", 5);
        TraceIn("numero", 5);
        int value = default(int);


        IToken INT2 = default(IToken);
        int expresion3 = default(int);

        try
        {
            DebugEnterRule(GrammarFileName, "numero");
            DebugLocation(37, 1);
            try
            {
                // C:\\Users\\dany_\\Desktop\\Calculadora1.g:38:2: ( INT | PARENI expresion PAREND )
                int alt4 = 2;
                try
                {
                    DebugEnterDecision(4, decisionCanBacktrack[4]);
                    int LA4_0 = input.LA(1);

                    if ((LA4_0 == INT))
                    {
                        alt4 = 1;
                    }
                    else if ((LA4_0 == PARENI))
                    {
                        alt4 = 2;
                    }
                    else
                    {
                        NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
                        DebugRecognitionException(nvae);
                        throw nvae;
                    }
                }
                finally { DebugExitDecision(4); }
                switch (alt4)
                {
                    case 1:
                        DebugEnterAlt(1);
                        // C:\\Users\\dany_\\Desktop\\Calculadora1.g:39:2: INT
                        {
                            DebugLocation(39, 2);
                            INT2 = (IToken)Match(input, INT, Follow._INT_in_numero246);
                            DebugLocation(39, 6);
                            value = int.Parse((INT2 != null ? INT2.Text : null));

                        }
                        break;
                    case 2:
                        DebugEnterAlt(2);
                        // C:\\Users\\dany_\\Desktop\\Calculadora1.g:41:2: PARENI expresion PAREND
                        {
                            DebugLocation(41, 2);
                            Match(input, PARENI, Follow._PARENI_in_numero258);
                            DebugLocation(41, 9);
                            PushFollow(Follow._expresion_in_numero260);
                            expresion3 = expresion();
                            PopFollow();

                            DebugLocation(41, 19);
                            Match(input, PAREND, Follow._PAREND_in_numero262);
                            DebugLocation(41, 27);
                            value = expresion3;

                        }
                        break;

                }
            }
            catch (RecognitionException re)
            {
                ReportError(re);
                Recover(input, re);
            }
            finally
            {
                TraceOut("numero", 5);
                LeaveRule("numero", 5);
                LeaveRule_numero();
            }
            DebugLocation(42, 1);
        }
        finally { DebugExitRule(GrammarFileName, "numero"); }
        return value;

    }
    // $ANTLR end "numero"
    #endregion Rules


    #region Follow sets
    private static class Follow
    {
        public static readonly BitSet _stat_in_programa61 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _expresion_in_stat90 = new BitSet(new ulong[] { 0x100UL });
        public static readonly BitSet _NEWLINE_in_stat92 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _NEWLINE_in_stat98 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _multiplicacion_in_expresion125 = new BitSet(new ulong[] { 0xC2UL });
        public static readonly BitSet _MAS_in_expresion133 = new BitSet(new ulong[] { 0x420UL });
        public static readonly BitSet _multiplicacion_in_expresion139 = new BitSet(new ulong[] { 0xC2UL });
        public static readonly BitSet _MENOS_in_expresion151 = new BitSet(new ulong[] { 0x420UL });
        public static readonly BitSet _multiplicacion_in_expresion157 = new BitSet(new ulong[] { 0xC2UL });
        public static readonly BitSet _numero_in_multiplicacion188 = new BitSet(new ulong[] { 0x812UL });
        public static readonly BitSet _POR_in_multiplicacion199 = new BitSet(new ulong[] { 0x420UL });
        public static readonly BitSet _numero_in_multiplicacion205 = new BitSet(new ulong[] { 0x812UL });
        public static readonly BitSet _ENTRE_in_multiplicacion214 = new BitSet(new ulong[] { 0x420UL });
        public static readonly BitSet _numero_in_multiplicacion220 = new BitSet(new ulong[] { 0x812UL });
        public static readonly BitSet _INT_in_numero246 = new BitSet(new ulong[] { 0x2UL });
        public static readonly BitSet _PARENI_in_numero258 = new BitSet(new ulong[] { 0x420UL });
        public static readonly BitSet _expresion_in_numero260 = new BitSet(new ulong[] { 0x200UL });
        public static readonly BitSet _PAREND_in_numero262 = new BitSet(new ulong[] { 0x2UL });
    }
    #endregion Follow sets
}
