//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\dany_\\Desktop\\antlr2020.g 2020-10-15 21:00:37

#define ANTLR_DEBUG
// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

using Antlr.Runtime.Debug;
using IOException = System.IO.IOException;
[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class antlr2020Parser : DebugAntlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "DIR", "DIRECCION", "MAYUSCULAS", "MINUSCULAS", "NOMBRE", "NUMERO", "OPDIRECTIVA", "OPERACION", "REGISTRO", "START", "TIPODIRECTIVA", "',X'", "'END'", "'\\n'"
	};
	public const int EOF=-1;
	public const int T__15=15;
	public const int T__16=16;
	public const int T__17=17;
	public const int DIR=4;
	public const int DIRECCION=5;
	public const int MAYUSCULAS=6;
	public const int MINUSCULAS=7;
	public const int NOMBRE=8;
	public const int NUMERO=9;
	public const int OPDIRECTIVA=10;
	public const int OPERACION=11;
	public const int REGISTRO=12;
	public const int START=13;
	public const int TIPODIRECTIVA=14;

	public static readonly string[] ruleNames =
		new string[]
		{
			"invalidRule", "directiva", "proposicion", "inicio", "final", "instruccion", 
		"programa"
		};

		int ruleLevel = 0;
		public virtual int RuleLevel { get { return ruleLevel; } }
		public virtual void IncRuleLevel() { ruleLevel++; }
		public virtual void DecRuleLevel() { ruleLevel--; }
		public antlr2020Parser( ITokenStream input )
			: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
		{
		}
		public antlr2020Parser( ITokenStream input, int port, RecognizerSharedState state )
			: base( input, state )
		{
			DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, null );

			DebugListener = proxy;
			try
			{
				proxy.Handshake();
			}
			catch ( IOException ioe )
			{
				ReportError( ioe );
			}
		}

	public antlr2020Parser( ITokenStream input, IDebugEventListener dbg )
		: base( input, dbg, new RecognizerSharedState() )
	{
	}

	protected virtual bool EvalPredicate( bool result, string predicate )
	{
		dbg.SemanticPredicate( result, predicate );
		return result;
	}


	public override string[] TokenNames { get { return antlr2020Parser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\Users\\dany_\\Desktop\\antlr2020.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_programa() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_programa() {}

	// $ANTLR start "programa"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:6:1: programa : inicio ( proposicion )* final ;
	[GrammarRule("programa")]
	private void programa()
	{
		EnterRule_programa();
		EnterRule("programa", 1);
		TraceIn("programa", 1);
		try { DebugEnterRule(GrammarFileName, "programa");
		DebugLocation(6, 36);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:6:9: ( inicio ( proposicion )* final )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:6:12: inicio ( proposicion )* final
			{
			DebugLocation(6, 12);
			PushFollow(Follow._inicio_in_programa38);
			inicio();
			PopFollow();

			DebugLocation(6, 19);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:6:19: ( proposicion )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, decisionCanBacktrack[1]);
				int LA1_0 = input.LA(1);

				if ((LA1_0==NOMBRE||LA1_0==OPERACION))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\Users\\dany_\\Desktop\\antlr2020.g:6:19: proposicion
					{
					DebugLocation(6, 19);
					PushFollow(Follow._proposicion_in_programa40);
					proposicion();
					PopFollow();


					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }

			DebugLocation(6, 32);
			PushFollow(Follow._final_in_programa43);
			final();
			PopFollow();


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("programa", 1);
			LeaveRule("programa", 1);
			LeaveRule_programa();
	    }
	 	DebugLocation(6, 36);
		} finally { DebugExitRule(GrammarFileName, "programa"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "programa"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_inicio() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_inicio() {}

	// $ANTLR start "inicio"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:8:1: inicio : NOMBRE START DIR '\\n' ;
	[GrammarRule("inicio")]
	private void inicio()
	{
		EnterRule_inicio();
		EnterRule("inicio", 2);
		TraceIn("inicio", 2);
		try { DebugEnterRule(GrammarFileName, "inicio");
		DebugLocation(8, 29);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:8:8: ( NOMBRE START DIR '\\n' )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:8:10: NOMBRE START DIR '\\n'
			{
			DebugLocation(8, 10);
			Match(input,NOMBRE,Follow._NOMBRE_in_inicio51); 
			DebugLocation(8, 17);
			Match(input,START,Follow._START_in_inicio53); 
			DebugLocation(8, 23);
			Match(input,DIR,Follow._DIR_in_inicio55); 
			DebugLocation(8, 26);
			Match(input,17,Follow._17_in_inicio56); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("inicio", 2);
			LeaveRule("inicio", 2);
			LeaveRule_inicio();
	    }
	 	DebugLocation(8, 29);
		} finally { DebugExitRule(GrammarFileName, "inicio"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "inicio"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_proposicion() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_proposicion() {}

	// $ANTLR start "proposicion"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:10:1: proposicion : ( instruccion | directiva ) ( '\\n' )? ;
	[GrammarRule("proposicion")]
	private void proposicion()
	{
		EnterRule_proposicion();
		EnterRule("proposicion", 3);
		TraceIn("proposicion", 3);
		try { DebugEnterRule(GrammarFileName, "proposicion");
		DebugLocation(10, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:2: ( ( instruccion | directiva ) ( '\\n' )? )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:4: ( instruccion | directiva ) ( '\\n' )?
			{
			DebugLocation(11, 4);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:4: ( instruccion | directiva )
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
			int LA2_0 = input.LA(1);

			if ((LA2_0==NOMBRE))
			{
				int LA2_1 = input.LA(2);

				if ((LA2_1==TIPODIRECTIVA))
				{
					alt2 = 2;
				}
				else if ((LA2_1==OPERACION))
				{
					alt2 = 1;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA2_0==OPERACION))
			{
				alt2 = 1;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:5: instruccion
				{
				DebugLocation(11, 5);
				PushFollow(Follow._instruccion_in_proposicion66);
				instruccion();
				PopFollow();


				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:17: directiva
				{
				DebugLocation(11, 17);
				PushFollow(Follow._directiva_in_proposicion68);
				directiva();
				PopFollow();


				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(11, 27);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:27: ( '\\n' )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_0 = input.LA(1);

			if ((LA3_0==17))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:11:27: '\\n'
				{
				DebugLocation(11, 27);
				Match(input,17,Follow._17_in_proposicion70); 

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("proposicion", 3);
			LeaveRule("proposicion", 3);
			LeaveRule_proposicion();
	    }
	 	DebugLocation(12, 1);
		} finally { DebugExitRule(GrammarFileName, "proposicion"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "proposicion"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_final() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_final() {}

	// $ANTLR start "final"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:1: final : 'END' ( NOMBRE )? ( '\\n' )? ;
	[GrammarRule("final")]
	private void final()
	{
		EnterRule_final();
		EnterRule("final", 4);
		TraceIn("final", 4);
		try { DebugEnterRule(GrammarFileName, "final");
		DebugLocation(14, 27);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:7: ( 'END' ( NOMBRE )? ( '\\n' )? )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:9: 'END' ( NOMBRE )? ( '\\n' )?
			{
			DebugLocation(14, 9);
			Match(input,16,Follow._16_in_final82); 
			DebugLocation(14, 15);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:15: ( NOMBRE )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_0 = input.LA(1);

			if ((LA4_0==NOMBRE))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:15: NOMBRE
				{
				DebugLocation(14, 15);
				Match(input,NOMBRE,Follow._NOMBRE_in_final84); 

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(14, 23);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:23: ( '\\n' )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, decisionCanBacktrack[5]);
			int LA5_0 = input.LA(1);

			if ((LA5_0==17))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:14:23: '\\n'
				{
				DebugLocation(14, 23);
				Match(input,17,Follow._17_in_final87); 

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("final", 4);
			LeaveRule("final", 4);
			LeaveRule_final();
	    }
	 	DebugLocation(14, 27);
		} finally { DebugExitRule(GrammarFileName, "final"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "final"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_instruccion() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_instruccion() {}

	// $ANTLR start "instruccion"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:16:1: instruccion : ( NOMBRE )? OPERACION ( NOMBRE )? ( ',X' )? '\\n' ;
	[GrammarRule("instruccion")]
	private void instruccion()
	{
		EnterRule_instruccion();
		EnterRule("instruccion", 5);
		TraceIn("instruccion", 5);
		try { DebugEnterRule(GrammarFileName, "instruccion");
		DebugLocation(16, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:2: ( ( NOMBRE )? OPERACION ( NOMBRE )? ( ',X' )? '\\n' )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:4: ( NOMBRE )? OPERACION ( NOMBRE )? ( ',X' )? '\\n'
			{
			DebugLocation(17, 4);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:4: ( NOMBRE )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, decisionCanBacktrack[6]);
			int LA6_0 = input.LA(1);

			if ((LA6_0==NOMBRE))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:4: NOMBRE
				{
				DebugLocation(17, 4);
				Match(input,NOMBRE,Follow._NOMBRE_in_instruccion97); 

				}
				break;

			}
			} finally { DebugExitSubRule(6); }

			DebugLocation(17, 12);
			Match(input,OPERACION,Follow._OPERACION_in_instruccion100); 
			DebugLocation(17, 22);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:22: ( NOMBRE )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
			int LA7_0 = input.LA(1);

			if ((LA7_0==NOMBRE))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:22: NOMBRE
				{
				DebugLocation(17, 22);
				Match(input,NOMBRE,Follow._NOMBRE_in_instruccion102); 

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(17, 29);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:29: ( ',X' )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, decisionCanBacktrack[8]);
			int LA8_0 = input.LA(1);

			if ((LA8_0==15))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\Users\\dany_\\Desktop\\antlr2020.g:17:29: ',X'
				{
				DebugLocation(17, 29);
				Match(input,15,Follow._15_in_instruccion104); 

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(17, 35);
			Match(input,17,Follow._17_in_instruccion107); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("instruccion", 5);
			LeaveRule("instruccion", 5);
			LeaveRule_instruccion();
	    }
	 	DebugLocation(18, 1);
		} finally { DebugExitRule(GrammarFileName, "instruccion"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "instruccion"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_directiva() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_directiva() {}

	// $ANTLR start "directiva"
	// C:\\Users\\dany_\\Desktop\\antlr2020.g:20:1: directiva : NOMBRE TIPODIRECTIVA OPDIRECTIVA ;
	[GrammarRule("directiva")]
	private void directiva()
	{
		EnterRule_directiva();
		EnterRule("directiva", 6);
		TraceIn("directiva", 6);
		try { DebugEnterRule(GrammarFileName, "directiva");
		DebugLocation(20, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:21:2: ( NOMBRE TIPODIRECTIVA OPDIRECTIVA )
			DebugEnterAlt(1);
			// C:\\Users\\dany_\\Desktop\\antlr2020.g:21:4: NOMBRE TIPODIRECTIVA OPDIRECTIVA
			{
			DebugLocation(21, 4);
			Match(input,NOMBRE,Follow._NOMBRE_in_directiva119); 
			DebugLocation(21, 11);
			Match(input,TIPODIRECTIVA,Follow._TIPODIRECTIVA_in_directiva121); 
			DebugLocation(21, 25);
			Match(input,OPDIRECTIVA,Follow._OPDIRECTIVA_in_directiva123); 

			}

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		}
		finally
		{
			TraceOut("directiva", 6);
			LeaveRule("directiva", 6);
			LeaveRule_directiva();
	    }
	 	DebugLocation(22, 1);
		} finally { DebugExitRule(GrammarFileName, "directiva"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return;

	}
	// $ANTLR end "directiva"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _inicio_in_programa38 = new BitSet(new ulong[]{0x10900UL});
		public static readonly BitSet _proposicion_in_programa40 = new BitSet(new ulong[]{0x10900UL});
		public static readonly BitSet _final_in_programa43 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOMBRE_in_inicio51 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _START_in_inicio53 = new BitSet(new ulong[]{0x10UL});
		public static readonly BitSet _DIR_in_inicio55 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_inicio56 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _instruccion_in_proposicion66 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _directiva_in_proposicion68 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _17_in_proposicion70 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _16_in_final82 = new BitSet(new ulong[]{0x20102UL});
		public static readonly BitSet _NOMBRE_in_final84 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _17_in_final87 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOMBRE_in_instruccion97 = new BitSet(new ulong[]{0x800UL});
		public static readonly BitSet _OPERACION_in_instruccion100 = new BitSet(new ulong[]{0x28100UL});
		public static readonly BitSet _NOMBRE_in_instruccion102 = new BitSet(new ulong[]{0x28000UL});
		public static readonly BitSet _15_in_instruccion104 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _17_in_instruccion107 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOMBRE_in_directiva119 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _TIPODIRECTIVA_in_directiva121 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _OPDIRECTIVA_in_directiva123 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
