//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\Users\\dany_\\Desktop\\prueba.g 2020-10-02 01:29:29

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class pruebaLexer : Antlr.Runtime.Lexer
{
	public const int EOF=-1;
	public const int ENTRE=4;
	public const int INT=5;
	public const int MAS=6;
	public const int MENOS=7;
	public const int NEWLINE=8;
	public const int PAREND=9;
	public const int PARENI=10;
	public const int POR=11;
	public const int WS=12;

    // delegates
    // delegators

	public pruebaLexer()
	{
		OnCreated();
	}

	public pruebaLexer(ICharStream input )
		: this(input, new RecognizerSharedState())
	{
	}

	public pruebaLexer(ICharStream input, RecognizerSharedState state)
		: base(input, state)
	{

		OnCreated();
	}
	public override string GrammarFileName { get { return "C:\\Users\\dany_\\Desktop\\prueba.g"; } }

	private static readonly bool[] decisionCanBacktrack = new bool[0];

	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PARENI() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PARENI() {}

    // $ANTLR start "PARENI"
    [GrammarRule("PARENI")]
    private void mPARENI()
    {
    	EnterRule_PARENI();
    	EnterRule("PARENI", 1);
    	TraceIn("PARENI", 1);
    		try
    		{
    		int _type = PARENI;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:48:2: ( '(' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:48:4: '('
    		{
    		DebugLocation(48, 4);
    		Match('('); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("PARENI", 1);
    		LeaveRule("PARENI", 1);
    		LeaveRule_PARENI();
        }
    }
    // $ANTLR end "PARENI"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_PAREND() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_PAREND() {}

    // $ANTLR start "PAREND"
    [GrammarRule("PAREND")]
    private void mPAREND()
    {
    	EnterRule_PAREND();
    	EnterRule("PAREND", 2);
    	TraceIn("PAREND", 2);
    		try
    		{
    		int _type = PAREND;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:51:2: ( ')' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:51:4: ')'
    		{
    		DebugLocation(51, 4);
    		Match(')'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("PAREND", 2);
    		LeaveRule("PAREND", 2);
    		LeaveRule_PAREND();
        }
    }
    // $ANTLR end "PAREND"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MAS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MAS() {}

    // $ANTLR start "MAS"
    [GrammarRule("MAS")]
    private void mMAS()
    {
    	EnterRule_MAS();
    	EnterRule("MAS", 3);
    	TraceIn("MAS", 3);
    		try
    		{
    		int _type = MAS;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:54:2: ( '+' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:54:4: '+'
    		{
    		DebugLocation(54, 4);
    		Match('+'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MAS", 3);
    		LeaveRule("MAS", 3);
    		LeaveRule_MAS();
        }
    }
    // $ANTLR end "MAS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_MENOS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_MENOS() {}

    // $ANTLR start "MENOS"
    [GrammarRule("MENOS")]
    private void mMENOS()
    {
    	EnterRule_MENOS();
    	EnterRule("MENOS", 4);
    	TraceIn("MENOS", 4);
    		try
    		{
    		int _type = MENOS;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:57:2: ( '-' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:57:4: '-'
    		{
    		DebugLocation(57, 4);
    		Match('-'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("MENOS", 4);
    		LeaveRule("MENOS", 4);
    		LeaveRule_MENOS();
        }
    }
    // $ANTLR end "MENOS"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_POR() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_POR() {}

    // $ANTLR start "POR"
    [GrammarRule("POR")]
    private void mPOR()
    {
    	EnterRule_POR();
    	EnterRule("POR", 5);
    	TraceIn("POR", 5);
    		try
    		{
    		int _type = POR;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:60:2: ( '*' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:60:4: '*'
    		{
    		DebugLocation(60, 4);
    		Match('*'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("POR", 5);
    		LeaveRule("POR", 5);
    		LeaveRule_POR();
        }
    }
    // $ANTLR end "POR"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_INT() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_INT() {}

    // $ANTLR start "INT"
    [GrammarRule("INT")]
    private void mINT()
    {
    	EnterRule_INT();
    	EnterRule("INT", 6);
    	TraceIn("INT", 6);
    		try
    		{
    		int _type = INT;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:63:2: ( ( '0' .. '9' )+ )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:63:3: ( '0' .. '9' )+
    		{
    		DebugLocation(63, 3);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:63:3: ( '0' .. '9' )+
    		int cnt1=0;
    		try { DebugEnterSubRule(1);
    		while (true)
    		{
    			int alt1=2;
    			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
    			int LA1_0 = input.LA(1);

    			if (((LA1_0>='0' && LA1_0<='9')))
    			{
    				alt1 = 1;
    			}


    			} finally { DebugExitDecision(1); }
    			switch (alt1)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// C:\\Users\\dany_\\Desktop\\prueba.g:
    				{
    				DebugLocation(63, 3);
    				input.Consume();


    				}
    				break;

    			default:
    				if (cnt1 >= 1)
    					goto loop1;

    				EarlyExitException eee1 = new EarlyExitException( 1, input );
    				DebugRecognitionException(eee1);
    				throw eee1;
    			}
    			cnt1++;
    		}
    		loop1:
    			;

    		} finally { DebugExitSubRule(1); }


    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("INT", 6);
    		LeaveRule("INT", 6);
    		LeaveRule_INT();
        }
    }
    // $ANTLR end "INT"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_ENTRE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_ENTRE() {}

    // $ANTLR start "ENTRE"
    [GrammarRule("ENTRE")]
    private void mENTRE()
    {
    	EnterRule_ENTRE();
    	EnterRule("ENTRE", 7);
    	TraceIn("ENTRE", 7);
    		try
    		{
    		int _type = ENTRE;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:66:2: ( '/' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:66:4: '/'
    		{
    		DebugLocation(66, 4);
    		Match('/'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("ENTRE", 7);
    		LeaveRule("ENTRE", 7);
    		LeaveRule_ENTRE();
        }
    }
    // $ANTLR end "ENTRE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_NEWLINE() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_NEWLINE() {}

    // $ANTLR start "NEWLINE"
    [GrammarRule("NEWLINE")]
    private void mNEWLINE()
    {
    	EnterRule_NEWLINE();
    	EnterRule("NEWLINE", 8);
    	TraceIn("NEWLINE", 8);
    		try
    		{
    		int _type = NEWLINE;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:70:2: ( '\\n' )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:70:4: '\\n'
    		{
    		DebugLocation(70, 4);
    		Match('\n'); 

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("NEWLINE", 8);
    		LeaveRule("NEWLINE", 8);
    		LeaveRule_NEWLINE();
        }
    }
    // $ANTLR end "NEWLINE"

    [Conditional("ANTLR_TRACE")]
    protected virtual void EnterRule_WS() {}
    [Conditional("ANTLR_TRACE")]
    protected virtual void LeaveRule_WS() {}

    // $ANTLR start "WS"
    [GrammarRule("WS")]
    private void mWS()
    {
    	EnterRule_WS();
    	EnterRule("WS", 9);
    	TraceIn("WS", 9);
    		try
    		{
    		int _type = WS;
    		int _channel = DefaultTokenChannel;
    		// C:\\Users\\dany_\\Desktop\\prueba.g:73:2: ( ( ' ' | '\\r' | '\\n' | '\\t' )+ )
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:73:4: ( ' ' | '\\r' | '\\n' | '\\t' )+
    		{
    		DebugLocation(73, 4);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:73:4: ( ' ' | '\\r' | '\\n' | '\\t' )+
    		int cnt2=0;
    		try { DebugEnterSubRule(2);
    		while (true)
    		{
    			int alt2=2;
    			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
    			int LA2_0 = input.LA(1);

    			if (((LA2_0>='\t' && LA2_0<='\n')||LA2_0=='\r'||LA2_0==' '))
    			{
    				alt2 = 1;
    			}


    			} finally { DebugExitDecision(2); }
    			switch (alt2)
    			{
    			case 1:
    				DebugEnterAlt(1);
    				// C:\\Users\\dany_\\Desktop\\prueba.g:
    				{
    				DebugLocation(73, 4);
    				input.Consume();


    				}
    				break;

    			default:
    				if (cnt2 >= 1)
    					goto loop2;

    				EarlyExitException eee2 = new EarlyExitException( 2, input );
    				DebugRecognitionException(eee2);
    				throw eee2;
    			}
    			cnt2++;
    		}
    		loop2:
    			;

    		} finally { DebugExitSubRule(2); }

    		DebugLocation(73, 26);
    		Skip();

    		}

    		state.type = _type;
    		state.channel = _channel;
    	}
    	finally
    	{
    		TraceOut("WS", 9);
    		LeaveRule("WS", 9);
    		LeaveRule_WS();
        }
    }
    // $ANTLR end "WS"

    public override void mTokens()
    {
    	// C:\\Users\\dany_\\Desktop\\prueba.g:1:8: ( PARENI | PAREND | MAS | MENOS | POR | INT | ENTRE | NEWLINE | WS )
    	int alt3=9;
    	try { DebugEnterDecision(3, decisionCanBacktrack[3]);
    	switch (input.LA(1))
    	{
    	case '(':
    		{
    		alt3 = 1;
    		}
    		break;
    	case ')':
    		{
    		alt3 = 2;
    		}
    		break;
    	case '+':
    		{
    		alt3 = 3;
    		}
    		break;
    	case '-':
    		{
    		alt3 = 4;
    		}
    		break;
    	case '*':
    		{
    		alt3 = 5;
    		}
    		break;
    	case '0':
    	case '1':
    	case '2':
    	case '3':
    	case '4':
    	case '5':
    	case '6':
    	case '7':
    	case '8':
    	case '9':
    		{
    		alt3 = 6;
    		}
    		break;
    	case '/':
    		{
    		alt3 = 7;
    		}
    		break;
    	case '\n':
    		{
    		int LA3_8 = input.LA(2);

    		if (((LA3_8>='\t' && LA3_8<='\n')||LA3_8=='\r'||LA3_8==' '))
    		{
    			alt3 = 9;
    		}
    		else
    		{
    			alt3 = 8;
    		}
    		}
    		break;
    	case '\t':
    	case '\r':
    	case ' ':
    		{
    		alt3 = 9;
    		}
    		break;
    	default:
    		{
    			NoViableAltException nvae = new NoViableAltException("", 3, 0, input);
    			DebugRecognitionException(nvae);
    			throw nvae;
    		}
    	}

    	} finally { DebugExitDecision(3); }
    	switch (alt3)
    	{
    	case 1:
    		DebugEnterAlt(1);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:10: PARENI
    		{
    		DebugLocation(1, 10);
    		mPARENI(); 

    		}
    		break;
    	case 2:
    		DebugEnterAlt(2);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:17: PAREND
    		{
    		DebugLocation(1, 17);
    		mPAREND(); 

    		}
    		break;
    	case 3:
    		DebugEnterAlt(3);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:24: MAS
    		{
    		DebugLocation(1, 24);
    		mMAS(); 

    		}
    		break;
    	case 4:
    		DebugEnterAlt(4);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:28: MENOS
    		{
    		DebugLocation(1, 28);
    		mMENOS(); 

    		}
    		break;
    	case 5:
    		DebugEnterAlt(5);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:34: POR
    		{
    		DebugLocation(1, 34);
    		mPOR(); 

    		}
    		break;
    	case 6:
    		DebugEnterAlt(6);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:38: INT
    		{
    		DebugLocation(1, 38);
    		mINT(); 

    		}
    		break;
    	case 7:
    		DebugEnterAlt(7);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:42: ENTRE
    		{
    		DebugLocation(1, 42);
    		mENTRE(); 

    		}
    		break;
    	case 8:
    		DebugEnterAlt(8);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:48: NEWLINE
    		{
    		DebugLocation(1, 48);
    		mNEWLINE(); 

    		}
    		break;
    	case 9:
    		DebugEnterAlt(9);
    		// C:\\Users\\dany_\\Desktop\\prueba.g:1:56: WS
    		{
    		DebugLocation(1, 56);
    		mWS(); 

    		}
    		break;

    	}

    }


	#region DFA

	protected override void InitDFAs()
	{
		base.InitDFAs();
	}

 
	#endregion

}
